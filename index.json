{
  "articles/api.html": {
    "href": "articles/api.html",
    "title": "API | aas-transformation-library Documentation",
    "keywords": "API For the end user, there are three relevant classes, all of which extend the DocumentTransformer Class public AssetAdministrationShellEnvironment transform(InputStream inStream, MappingSpecification mapping, Map<String, String> initialVars); This requires three inputs for transformation: A source xml-based document as an InputStream (inStream). A MappingSpecification Object, that holds a parsed json-config file. This can be obtained from the MappingSpecificationParser: new MappingSpecificationParser().loadMappingSpecification(PATH_TO_CONFIG_JSON) Optionally, the user can set the parameters declared by the @parameters section in the config file as a Map<String, String>. If the config does not define such parameters null can be passed which is equivalent to a second transform-method taking only the first two arguments. Depending on what kind of document shall be transformed, different classes should be used: AML files AML files can be transformed by calling the AmlTransformer : AmlTransformer amlTransformer = new AmlTransformer(); shellEnv = amlTransformer.execute(amlInputStream, mapping); AML file validation includes the following steps (cf. AmlValidator.java ): Check that the AML file is a valid XML file Check that the AML file is valid according to the CAEX 3.0 class model AMLX files AMLX contains a AML-file at its core that needs to be unpackaged first AmlxPackage amlxPackage = new AmlxPackageReader().readAmlxPackage(Paths.get(amlxInputFileName).toFile()); InputStream amlInputStream = amlxPackage.getRootAmlFile().getInputStream() After that the tranformation is equivalent to that of an AML-file. AMLX file validation includes the following steps (cf. AmlxValidator.java ): Check whether each document defined in /_rels/.rels exists Check whether each file in the AMLX file (a ZIP archive) is defined in /_rels/.rels Check that the root document exists Check that there is exactly one root document Check that the root document is a valid AML file OPC UA Nodeset files Due to the UANodeSetTransformer inheriting methods from the DocumentTransformer, transforming UA is very similar to AML. UANodeSetTransformer uaTransformer = new UANodeSetTransformer(); shellEnv = uaTransformer.execute(amlInputStream, mapping); The OPC UA Nodeset validation includes the following (cf. UANodeSetSchemaValidator.java ): Check that the nodeset xml file is valid xml file. Check that the nodeset xml file is valid according to UANodeSet.xsd V1.04 schema. Please note : The nodeset EntType.xml is taken from OPC UA information models published by Equinor . Plain XML files Plain XML files can be tranformed using the GenericDocumentTransformer. This transformer does not trigger any validation but also prohibits users from accessing meta-model specific expressions such as @caexAttributeName or @uaChildren ."
  },
  "articles/building.html": {
    "href": "articles/building.html",
    "title": "Importing the AAS Transformation Library | aas-transformation-library Documentation",
    "keywords": "Importing the AAS Transformation Library Usage as a dependency Currently, builds are exclusively released to GitHub Packages. They can be imported into gradle and maven projects with adjusted versioning, for example: <dependency> <groupId>com.sap.dsc.aas.lib</groupId> <artifactId>aas-transformation-library</artifactId> <version>0.0.1-SNAPSHOT</version> </dependency> Local Usage We rely on SapMachine 11 and use Gradle . You can download and build the repository by yourself by following these steps: Clone the GitHub repository: git clone https://github.com/admin-shell-io/aas-transformation-library Use the repository on the commandline. Adjust the name of the jar according to your build. $ ./gradlew build $ java -jar build/distributions/aas-transformation-library-shadow-0.0.1-SNAPSHOT.jar usage: transform [-a <AML_INPUT_FILE> | -amlx <AMLX_INPUT_FILE> | -ua <NODESET_INPUT_FILE> | -xml <GENERIC_INPUT_FILE>] -c <CONFIG_FILE> [-P <PLACEHOLDER_VALUES_JSON>] [-p] Transform XML file into an AAS structured file -a,--aml <AML_INPUT_FILE> AML input file -amlx,--amlx <AMLX_INPUT_FILE> AMLX input file -c,--config <CONFIG_FILE> Mapping config file -P,--placeholder-values <PLACEHOLDER_VALUES_JSON> Map of placeholder values in JSON format -p,--print-placeholders Print placeholders with description -ua,--ua <NODESET_INPUT_FILE> UA NodeSet input file -xml,--xml <GENERIC_INPUT_FILE> Generic input file Missing required option: c $ java -jar ./build/distributions/aas-transformation-library-shadow-0.0.1-SNAPSHOT.jar -c src/test/resources/config/simpleConfig.json -a src/test/resources/aml/full_AutomationComponent.aml [main] INFO com.sap.dsc.aas.lib.aml.ConsoleApplication - Loaded config version 1.0.0, aas version 2.0.1 [main] INFO transform.aml.org.eclipse.digitaltwin.aas4j.AmlTransformer - Loaded config version 1.0.0, AAS version 2.0.1 [main] INFO com.sap.dsc.aas.lib.aml.transform.AssetAdministrationShellEnvTransformer - Transforming 1 config assets... [main] INFO com.sap.dsc.aas.lib.aml.ConsoleApplication - Wrote AAS file to full_AutomationComponent.json $ cd src/test/resources/amlx/minimal_AutomationMLComponent_WithDocuments $ zip -r minimal_AutomationMLComponent_WithDocuments.amlx . -x \"*.DS_Store\" adding: [Content_Types].xml (deflated 52%) adding: _rels/ (stored 0%) adding: _rels/.rels (deflated 68%) adding: lib/ (stored 0%) adding: lib/AutomationComponentLibrary_v1_0_0_Full_CAEX3_BETA.aml (deflated 85%) adding: files/ (stored 0%) adding: files/TestPDFDeviceManual.pdf (deflated 14%) adding: files/TestTXTDeviceManual.txt (stored 0%) adding: files/TestTXTWarranty.txt (stored 0%) adding: CAEX_ClassModel_V.3.0.xsd (deflated 90%) adding: minimal_AutomationMLComponent_WithDocuments.aml (deflated 80%) $ cd ../../../../../ $ java -jar ./build/distributions/aas-transformation-library-shadow-0.0.1-SNAPSHOT.jar -c src/test/resources/config/simpleConfig.json -amlx src/test/resources/amlx/minimal_AutomationMLComponent_WithDocuments/minimal_AutomationMLComponent_WithDocuments.amlx [main] INFO com.sap.dsc.aas.lib.aml.ConsoleApplication - Loaded config version 1.0.0, aas version 2.0.1 [main] INFO transform.aml.org.eclipse.digitaltwin.aas4j.AmlTransformer - Loaded config version 1.0.0, AAS version 2.0.1 [main] INFO com.sap.dsc.aas.lib.aml.transform.AssetAdministrationShellEnvTransformer - Transforming 1 config assets... [main] INFO com.sap.dsc.aas.lib.aml.ConsoleApplication - Wrote AAS file to minimal_AutomationMLComponent_WithDocuments.json Writing to: minimal_AutomationMLComponent_WithDocuments/files/TestTXTDeviceManual.txt Writing to: minimal_AutomationMLComponent_WithDocuments/files/TestPDFDeviceManual.pdf Writing to: minimal_AutomationMLComponent_WithDocuments/files/TestTXTWarranty.txt Output was shortened for increased readability. Versioning We version using semantic versioning (e.g., 1.0.4 ). The first position indicates the major release. Different major releases canvas contain breaking changes and are not necessarily compliant. The second number indicates the minor release or revision, which contains new features compared to an older revision. The last position is used for hotfixes or bugfixes. Note, that the versioning scheme of this project is not directly aligned with the release process of the metamodel or the java-model library! When revisions of the meta-model are released, the java-model will change and those changes will be integrated in this library eventually."
  },
  "articles/configuration.html": {
    "href": "articles/configuration.html",
    "title": "Configuration | aas-transformation-library Documentation",
    "keywords": "Configuration Basic Structure Asset Administration Shells are instantiated using a dialect of the AAS-JSON serialization format . The following json shows the structure of the dialect. The relevance of each section in the header will be explained by the individual paragraphs. { \"@header\": { \"aasVersion\": \"3.0RC01\", \"@namespaces\": {}, \"@definitions\": {}, \"@variables\": {}, \"@parameters\": {} }, \"aasEnvironmentMapping\": [ { \"assetAdministrationShells\": [], \"assets\": [], \"submodels\": [], \"conceptDescriptions\": [] } ] } Due to this structure, data that is given in the aasEnvironmentMapping section can be parsed as AAS directly if no other concepts are applied. The diff demonstrates this - the header is not in the resulting AAS-JSON but everything else is: However, this is purely static and does not process any data from the source file. Expressions Expressions are objects denoted by a @ at the beginning of the json-key and signify a side-effect during runtime. While those configurations with no expression in their context are just parsed as AAS-JSON, expressions are evaluated with their result determining the structure of the resulting AAS objects. Examples include: @xpath for evaluation of xPath-Queries @caexAttributeName to fetch the attribute name of an element in a AutomationML file. Takes a string. @uaBrowsePath gets a Node's NodeId by its BrowsePath from a OPC UA nodeset file. Takes a list of BrowseNames connected by hierarchical ReferenceTypes. This is called the BrowsePath in OPC UA. @uaChildren takes a BrowsePath (see above) and returns all Nodes that are connected to this node via a hierarchical ReferenceType. Several basic mathematical and boolean operations such as @plus , @times , @max , @negate or @and . Please note that Expressions can only be called from within a @bind - or @foreach -context. Looping with @foreach On every level (except for the aasEnvironmentMapping ) objects can be dynamically generated using this feature. It evaluates the expression and builds objects according to the statements below - once for every returned value. The syntax is as follows: { \"@foreach\": { \"@xpath\": \"someXpath\" }, \"xyz\": \"abc\" } Dynamic evaluation with @bind Looping around the results of an expression would be obsolete if all resulting objects would hold the same values. That's why the @bind Context allows to fill AAS-attributes with the result of an expression. It may only return a single value that will be used. If I wanted to configure changing idShorts based on the iterator, it could look like this: { \"@foreach\": { \"@xpath\": \"someXpathQuery\" }, \"@bind\": { \"idShort\": { \"@xpath\": \"somePotentiallyRelativeXpathQuery\" } } } Pre-defined Expressions with @definitions Usually in the @header (but everywhere else is fine as well), the config can define more complex functions that will then be called using the @def -key in the @bind -context.In the example below, the exampleFunction is called to assign an id to an AAS. { \"@headers\": { \"@definitions\": { \"exampleFunction\": { \"@concatenate\": [ { \"@xpath\": \"someXpath\" }, \"/\", { \"@xpath\": \"someOtherXpath\" } ] } } }, \"aasEnvironmentMapping\": { ..., \"assetAdministrationShells\": { \"identification\": { \"@bind\": { \"id\": { \"@def\": \"exampleFunction\" } } } } } } Variables and Parameters Variables and Parameters are very similar in that they allow to reuse a value by binding it to a variable name. They are initialized in the header in the @variables section, can be called by @var in the @bind -context and updated by repeating the @variables section in the aasEnvironmentMapping section. Parameters cannot be updated in the config and are not assigned a value in the header. They are given a description and are set during runtime from the outside. The CLI and the library both allow to pass data setting the parameters that must however be declared in the config header. They are also called by @var in the @bind context. Auto-Wiring submodels There are two options to assign a Submodel to a AssetAdministrationShell. The submodel can be passed explicitly as a Reference as the json-schema demands. If however the configuration leaves the submodels list empty in the config-json, all submodels will be bound to all AssetAdministrationShells. This behaviour differs from the rest of the library as attributs that are not given in the config are usually just set to null ."
  },
  "articles/development_workflow.html": {
    "href": "articles/development_workflow.html",
    "title": "Development Workflow | aas-transformation-library Documentation",
    "keywords": "Development Workflow We develop with Github using pull requests (see this Github guide for a short introduction). Development branch. The development branch is always development . Expect changes on this branch from time to time. Releases. The releases mark the development milestones on the main branch with a certain feature completeness. Every push/accepted merge request to the main branch will trigger a release. Please ensure the correct versioning in the build.gradle file. Pull Requests Feature branches. We develop using the feature branches, see this section of the Git book . We use feature/'feature-name' and bugfix/'bugfix-name' as a naming convention. If you are a member of the development team, create a feature branch directly within the repository. Otherwise, if you are a non-member contributor, fork the repository and create the feature branch in your forked repository. Developers can open pull requests that will be reviewed and merged to the development branch. Branch Prefix. Each PullRequest must contained a list of the changed topics, for instance as a list of bulletpoints. Simply refering to the commit messages is not sufficient. Reviews. Each PullRequest is reviewed by the Maintainers of the project. In order to simplify the workflow, please assign the PullRequest directly to the Maintainer you think is most knowledgable about your changes. Commit Messages The commit messages should follow the guidelines from this guide : Separate subject from body with a blank line Limit the subject line to 50 characters Capitalize the subject line Do not end the subject line with a period Use the imperative mood in the subject line Wrap the body at 72 characters Use the body to explain what and why (instead of how)"
  },
  "index.html": {
    "href": "index.html",
    "title": "Introduction | aas-transformation-library Documentation",
    "keywords": "Introduction The AAS Transformation Library is a software tool that eases the process of creating Asset Administration Shells from other XML-based formats. This functility is critical to integrate existing XML-based industry standard in the AAS, most notably OPC UA Nodeset and AutomationML files (.aml, .amlx). As it builds on open standards, the library is also usable for generic XML-files, however without domain-specific extensions. This library is no competitor to the OPC UA and AutomationML serializations defined in the specification Details of the Asset Administration Shell Pt. 1 as the spec only defines ways to express AAS-native structures in the meta-models of AML or OPC UA. The OPC UA Companion Specification OPC UA for Asset Administration Shell is equivalent to the OPC UA serialization in the spec. This library depends heavily on the implementation of the AAS in java and the corresponding json-deserializer . Scope The AAS strives to provide a generic data model for industrial assets. However, depending on the scope, lifecycle stage and industry, the structure and semantics of a production plants may already be modelled elsewhere. To make use of this knowledge, users require a semi-automatic way to translate other standards to the AAS. This library can help. The library can be used twofold. Users can.. import the library in Java applications to transform models using the most relevant XML-based industrial standards into AAS objects. use the library to build a fat JAR to transform XML files into AAS JSON files locally. It requires two inputs: The first is the file with the source data and the second is a file that tells the transformation engine, how to conduct the mapping. When called from the commandline, the resulting AAS will be serialized to json and written to a file. When used as a dependency in another java-project, it will return an AssetAdministrationShellEnvironment object from the abovementioned java-model library. The user must decide what transformer to use depending on the format of the source file. The project was kicked-off by SAP for AutomationML-transformations and extended its scope from there."
  }
}